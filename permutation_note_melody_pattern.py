import random
from enum import Enum
import numpy as np
from music21 import instrument, metadata, note, stream

# Definimos el numero de filas (instrumentos)
numero_de_filas = 1

# Definición de la escala diatónica utilizando valores MIDI


class DiatonicScale(Enum):
    # C4 = 60
    D4 = 62
    # E4 = 64
    F4 = 65
    G4 = 67
    # A4 = 69
    Bb4 = 70
    C5 = 72
    # D5 = 74
    # E5 = 76
    # F5 = 77

# Definición de los estados de las notas


class NoteStates(Enum):
    OFF = 0
    ON = 1
    MUTATE = 2

# Generador de notas basado en autómatas celulares


class CellularAutomatonNoteGenerator:
    MUTATION_PROBABILITY = 0.1  # Probabilidad de cambiar el estado a MUTATE
    # Probabilidad de cambiar el estado de MUTATE a ON
    MUTATION_TRANSITION_PROBABILITY = 0.5

    def __init__(self, pattern_length):
        self.pattern_length = pattern_length
        self.state = self._initialize_state(pattern_length)
        self._rules = {
            "filling_gaps": self._apply_filling_gaps_rule,
            "mutation": self._apply_mutation_rule,
        }

    def step(self):
        # Aplica las reglas para cada posición en el patrón
        new_state = self.state.copy()
        for position in range(self.pattern_length):
            new_state = self._apply_rules(position, new_state)
        self.state = new_state

    def _initialize_state(self, pattern_length):
        # Inicializa el estado con valores aleatorios de OFF, ON, o MUTATE
        return np.random.choice(
            [NoteStates.OFF.value, NoteStates.ON.value, NoteStates.MUTATE.value],
            size=(numero_de_filas, pattern_length),
        )

    def _apply_rules(self, position, new_state):
        # Aplica todas las reglas definidas para una posición específica
        for rule in self._rules.values():
            new_state = rule(position, new_state)
        return new_state

    def _apply_filling_gaps_rule(self, position, new_state):
        # Rellena los huecos entre notas activas
        previous_position = self._get_previous_position(position)
        next_position = self._get_next_position(position)

        for note_index in range(numero_de_filas):
            if (
                self.state[note_index][previous_position] == NoteStates.OFF.value
                and self.state[note_index][position] == NoteStates.OFF.value
            ):
                new_state[note_index][next_position] = NoteStates.ON.value

        return new_state

    def _get_previous_position(self, position):
        # Obtiene la posición anterior en el patrón (considerando el patrón como circular)
        if position > 0:
            return position - 1
        return self.pattern_length - 1

    def _get_next_position(self, position):
        # Obtiene la posición siguiente en el patrón (considerando el patrón como circular)
        return (position + 1) % self.pattern_length

    def _apply_mutation_rule(self, position, new_state):
        # Aplica la regla de mutación para cambiar estados ON a MUTATE y viceversa
        for note_index in range(numero_de_filas):
            if self.state[note_index][position] == NoteStates.ON.value and random.random() < self.MUTATION_PROBABILITY:
                new_state[note_index][position] = NoteStates.MUTATE.value
            elif self.state[note_index][position] == NoteStates.MUTATE.value and random.random() < self.MUTATION_TRANSITION_PROBABILITY:
                new_state[note_index][position] = NoteStates.ON.value

        return new_state

    def print_state_info(self):
        total_on = np.sum(self.state == NoteStates.ON.value)
        total_mutate = np.sum(self.state == NoteStates.MUTATE.value)
        total_off = np.sum(self.state == NoteStates.OFF.value)
        print(f"Filas (instrumentos): {numero_de_filas}")
        print(f"Columnas (notas en el patrón): {self.pattern_length}")
        print(f"Estados ON: {total_on}")
        print(f"Estados MUTATE: {total_mutate}")
        print(f"Estados OFF: {total_off}")

# Convertidor de patrones de notas a partituras music21


class NotePatternMusic21Converter:
    def to_music21_score(self, state):
        score = stream.Score()
        score.metadata = metadata.Metadata(
            title="Melody Pattern generated by Cellular Automaton"
        )

        for fila in range(numero_de_filas):
            part = self._note_pattern_to_music21_part(state[fila])
            score.append(part)

        return score

    def _note_pattern_to_music21_part(self, fila_state):
        part = stream.Part()
        part.insert(0, instrument.Piano())

        for position in range(len(fila_state)):
            if fila_state[position] == NoteStates.ON.value:
                # Crear una nota y añadirla a la partitura
                note_pitch = random.choice(list(DiatonicScale)).value
                note_obj = note.Note()
                note_obj.pitch.midi = note_pitch
                note_obj.duration.quarterLength = 0.25  # duración de las notas
                part.append(note_obj)
            elif fila_state[position] == NoteStates.MUTATE.value:
                # Crear una nota mutada (diatónica) y añadirla a la partitura
                note_pitch = random.choice(list(DiatonicScale)).value
                note_obj = note.Note()
                note_obj.pitch.midi = note_pitch
                note_obj.duration.quarterLength = 0.25  # duración
                part.append(note_obj)
            else:
                # Añadir un silencio a la partitura
                part.append(note.Rest(quarterLength=0.25))

        return part

# Función principal para generar y mostrar la partitura


def main():
    note_generator = CellularAutomatonNoteGenerator(
        pattern_length=200)  # cantidad de cells (notas o silencios)
    music_converter = NotePatternMusic21Converter()

    for _ in range(8):
        # Realiza 8 pasos del autómata celular
        note_generator.step()
    score = music_converter.to_music21_score(note_generator.state)

    note_generator.print_state_info()  # Imprimir información del estado

    score.show()


if __name__ == "__main__":
    main()
