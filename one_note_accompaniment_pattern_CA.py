import random
from enum import Enum
import numpy as np
from music21 import instrument, metadata, note, stream


class DiatonicScale(Enum):
    C = 60
    D = 62
    # E = 64
    F = 65
    G = 67
    # A = 69
    Bb = 70


class NoteStates(Enum):
    OFF = 0
    ON = 1


class CellularAutomatonNoteGenerator:
    MUTATION_PROBABILITY = 0.1

    def __init__(self, pattern_length):
        self.pattern_length = pattern_length
        self.state = self._initialize_state(pattern_length)
        self._rules = {
            "filling_gaps": self._apply_filling_gaps_rule,
            "mutation": self._apply_mutation_rule,
        }

    def step(self):
        new_state = self.state.copy()
        for position in range(self.pattern_length):
            new_state = self._apply_rules(position, new_state)
        self.state = new_state

    def _initialize_state(self, pattern_length):
        return np.random.choice(
            [NoteStates.OFF.value, NoteStates.ON.value],
            size=(len(DiatonicScale), pattern_length),
        )

    def _apply_rules(self, position, new_state):
        for rule in self._rules.values():
            new_state = rule(position, new_state)
        return new_state

    def _apply_filling_gaps_rule(self, position, new_state):
        previous_position = self._get_previous_position(position)
        next_position = self._get_next_position(position)

        for note_index in range(len(DiatonicScale)):
            if (
                self.state[note_index][previous_position] == NoteStates.OFF.value
                and self.state[note_index][position] == NoteStates.OFF.value
            ):
                new_state[(note_index + 1) % len(DiatonicScale)][
                    next_position
                ] = NoteStates.ON.value

        return new_state

    def _get_previous_position(self, position):
        if position > 0:
            return position - 1
        return self.pattern_length - 1

    def _get_next_position(self, position):
        return (position + 1) % self.pattern_length

    def _apply_mutation_rule(self, position, new_state):
        if random.random() < self.MUTATION_PROBABILITY:
            note_index = random.randint(0, len(DiatonicScale) - 1)
            new_note_state = random.choice(
                [NoteStates.ON.value, NoteStates.OFF.value])
            new_state[note_index][position] = new_note_state

        return new_state


class NotePatternMusic21Converter:
    def to_music21_score(self, state):
        score = stream.Score()
        score.metadata = metadata.Metadata(
            title="One note accompaniment generated by Cellular Automaton"
        )

        pattern_length = len(state[0])
        for note_index, note_scale in enumerate(DiatonicScale):
            part = self._note_pattern_to_music21_part(
                note_scale, state, note_index, pattern_length)
            score.append(part)

        return score

    def _note_pattern_to_music21_part(self, note_scale, state, note_index, pattern_length):
        part = stream.Part()
        part.insert(0, instrument.Piano())

        for position in range(pattern_length):
            if state[note_index][position] == NoteStates.ON.value:
                note_pitch = note_scale.value
                note_obj = note.Note()
                note_obj.pitch.midi = note_pitch
                note_obj.duration.quarterLength = 0.25  # Semicorchea
                part.append(note_obj)
            else:
                # silencio
                part.append(note.Rest(quarterLength=0.25))

        return part


def main():
    note_generator = CellularAutomatonNoteGenerator(pattern_length=400)
    music_converter = NotePatternMusic21Converter()

    for _ in range(8):
        note_generator.step()
    score = music_converter.to_music21_score(note_generator.state)

    score.show()


if __name__ == "__main__":
    main()
